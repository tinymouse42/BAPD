      ________      _____ ______       ________      ________
      |\_____  \    |\   _ \  _   \    |\   __  \    |\   ____\
       \|___/  /|   \ \  \\\__\ \  \   \ \  \|\  \   \ \  \___|
           /  / /    \ \  \\|__| \  \   \ \   __  \   \ \  \
          /  /_/__    \ \  \    \ \  \   \ \  \ \  \   \ \  \____
         |\________\   \ \__\    \ \__\   \ \__\ \__\   \ \_______\
          \|_______|    \|__|     \|__|    \|__|\|__|    \|_______|

___ _  _        _  __ _  _     __ _  _  __ __    _  __ __ __    _     __ _
 _/(_)/ \   |V||_|/  |_)/ \   /  |_)/ \(_ (_ ---|_|(_ (_ |_ |V||_)|  |_ |_)
/__(_)\_/   | || |\__| \\_/   \__| \\_/__)__)   | |__)__)|__| ||_)|__|__| \


******************************************************************************
Version: 18oct2022
This updated version was of ZMAC was produced by George Phillips
http://48k.ca/zmac.html
For full credits, please see the end of this document.

NOTE: This is a modified and abridged version for the BAPD program. With any major document change errors could creep in. If something does not behave as the documentation states, please see the original full documentation at the link above.
-Dave Turner 05/09/2024
******************************************************************************

OVERVIEW

ZMAC is a versatile Z-80 macro cross-assembler. It takes your source code and generates executable program files in various formats. ZMAC also creates a '.lst' file, providing a well-formatted listing of your code alongside machine code and cycle counts for analysis. Undocumented Z80 instructions are supported. See http://www.z80.info/zip/z80-documented.pdf for more information.

==========TEST THIS=========

ZMAC automatically organizes its output files into a 'zout' subdirectory to streamline your workspace. For example, if your input file is 'file.z', you'll find the listing in 'zout/file.lst' and the TRS-80 executable in 'zout/file.cmd'. For more control over output file formats and locations, use the options '-o', '--oo', '--xo', and '--xd' when working with makefiles or development environments.

============================



ZMAC strives to be a powerful assembler with expressions familiar to C
programmers while providing good backward compatibility with original
assemblers such as Edtasm, MRAS and Macro-80.

USAGE

zmac
[ --help ]
[ --version ]
[ --od dir ]
[ --oo sfx1,sfx2 ]
[ --xo sfx1,sfx2 ]
[ --nmnv ]
[ --fcal ]
[ --doc ]
[ -bcfimnopstz ]

OPTIONS

--help

Displays a list of available options with brief descriptions.

--version
Prints the current ZMAC version.

--od dir
Sets the default output directory to the user-specified directory (dir). All generated files will be placed in this directory unless otherwise specified.

--oo sfx1,sfx2
Enables output in the specified formats.  Example: --oo hex,lst,bin
Refer to ZMAC documentation for a full list of supported suffixes.

--xo sfx1,sfx2
Disables output in the specified formats. Example: zmac --xo lst,hex project.asm This example suppresses the generation .lst and and .hex files.
All other standard output files would still be produced.

--nmnv
Disables the use of Z-80/8080 instruction mnemonics as values within expressions.  Example: defb ret  ; Error: 'ret' would be undefined.

--doc
Prints the full ZMAC documentation in HTML format to standard output.

--fcal
Any identifier in the first column must have a colon to be considered a label.

-b
Suppresses machine code output. Useful for syntax checks or when only the listing file is needed.

-c
Suppresses the display of cycle count information in the assembly listing.

By default, ZMAC includes cycle counts for each instruction, aiding in performance analysis.

ZMAC Default:

Address  Machine Code  Assembly      Cycles
-------  ------------  ---------     ------
0000     3E 0A         ld a,10       7

With -c Option: The cycle count column is removed:

Address  Machine Code  Assembly
-------  ------------  ---------
0000     3E 0A         ld a,10

-f
Includes instructions that were excluded from assembly due to IF expressions evaluating to false.

-i
Suppresses the display of files included using INCLUDE, READ, or INPORT.

-I dir
Adds user-specified directory (dir) to the search path for files for INCLUDE, READ, or INPORT.

-m
Displays macro expansions in the assembly listing for debugging and analysis.

-o filename.cmd
Instructs ZMAC to generate only the file with the specified name and suffix (e.g., .hex, .bin .lst) overriding ZMAC's default behavior of creating multiple output formats. Example: zmac -o program.hex will only generate the .hex file and suppress all others. It can be used multiple times in a single command. Example: zmac -o program.hex -o program.bin program.asm would only generate the .hex and .bin files.

-s
Omits the symbol table from the assembly listing.

-z

Enables Z-80 mnemonics and instruction timings.

Z-80 Mnemonics:  Tells ZMAC to recognize and assemble the full set of Z-80 instructions, including those that are not part of the original 8080 instruction set.
Z-80 Instruction Timings: Instructs ZMAC to use the correct cycle counts for all Z-80 instructions when calculating timing information for your code.



---
.Input Format

ZMAC uses the standard Zilog mnemonics and assembler directives. Variations that are valid are listed below.

ZMAC is case-insensitive, meaning that uppercase, lowercase, or mixed case is considered the same. Example: LABEL1, Label1 and LaBel1 are treated as the same word.

A leading dot (".") can be optionally added to any directive. For example, ".org" and "org" are equivalent.

Comments start with ";" and carry on to the end of the line.

Number constants can use a trailing "h" or a leading "$" or "0x" for hex,
a trailing "b" for binary, a trailing "o" or "q" for octal, or a trailing
"d" for decimal. Since decimal is the default, you can omit the trailing "d" (e.g., 123 is the same as 123d).

For flexibility, ZMAC allows you to use assembly mnemonics directly as data values. For example, "mvi a,xra" will load the A register with $A8 and "dw ldir" will output the same data as an ldir instruction ($B0ED). This feature can be disable with the --nmnv command-line option.

Define labels using either 'label:' or simply 'label'. Indentation doesn't matter. Labels can be up to 40 characters long and may contain letters, digits, '_', '$', '.', '?', and '@'.  Identifiers like '$FCB' are treated as hexadecimal constants unless you explicitly define them as labels by adding a trailing colon (e.g., '$FCB:'). Labels are case insenitive.

Alternate Register Notation: You can add a single quote (') to the end of register names to indicate the use of alternate registers with the exx and ex instructions but this is optional. Example: ex af, af' and ex af, af are considered equivilent. Using the single quote feature improves code readability, especially when performing many register swaps.

Here is how other things work.  Numbers are used as examples, but a full
expression@expr can be used in their place.

=============================

..Data

defb 42
|A byte.  ascii, byte, db, defm, dm and text are synonyms.

defb 'foobar'
|An ASCII character string (not NUL-terminated).
|Double quotes can also be used.

defb 'Who needs anything more than CP/M?',13,10,'$'
|Strings and bytes can mix together.

defw 2112

defw $123,0x456
|A word (16 bits).  word and dw are synonyms.

def3 $123456
|A 3 byte word (24 bits). d3 is a synonym.

defd $12345678
|A double word (32 bits). dword is a synonym.

defs 500
|Skip output ahead 500 bytes.  This will insert 500 zeros in the ".ams"
|and ".cim" output files or if inside a ".phase" section.
|block, ds and rmem are synonyms.

dc 'string'
|Like ascii but accepts only a single string and the high bit of the
|last character will be set. bytes is a synonym.

dc count,value
|Repeat the byte value a total of count times.  Similar to defs
|except that memory is always filled with value.

incbin file
|Inserts the raw contents of the file into the assembly.  Simpler for
|large amounts of data.

..Symbols

label equ 100
|Define a symbol to have a fixed value.  The symbol can be used before it
|is defined.  A symbol defined with equ or as a label can be defined only
|once, except that a symbol defined with equ may be redefined to the
|same value.

varname defl 200
|Define a symbol to have a changeable value.  The symbol cannot be used
|before it is defined, and it can be redefined to a different value later
|with another defl. aset, set and = are synonyms (despite set
|also being a Z-80 mnemonic).

varname OP = expression
|Shorthand for varname defl varname OP expression.  Allows for C-like
|handling of variable such as var += 5.  OP can be +, -, *, /,
|%, &, |, ^, <<, >>, && or ||.

varname++
|Shorthand for varname defl varname + 1

varname--
|Shorthand for varname defl varname - 1

min

max
|Same as defl except that the symbol is defined as the
|smaller or bigger of two comma-separated expressions.

name equ register
|Define a symbol to be an alias of a register.  count equ bc lets count
|stand for register bc so push count and dec count will both operate on
|register bc.

*mod
|Increment the internal module name string.  The first time this results
|in "a".  Then "b", "c", ... "z".  Then "aa", "ab", "ac", etc. all the way
|up to "zzzz".  The module name string is used in --mras mode where "?" in
|label names is replaced with the current module name.

extern lab1,lab2,...
|The listed labels are defined in an external module for later linking.
|No effect unless ZMAC is producing ".rel" output.
|ext and extrn are synonyms.

public lab1,lab2,...
|The given labels will be visible to external modules when linking.
|No effect unless ZMAC is producing ".rel" output.
|global and entry are synonyms.

label ++
|Equivalent to label defl label + 1.

label --
|Equivalent to label defl label - 1.

label += 10

label -= 10

|Equivalent to label defl label + 10 and label defl label - 10 respectively.
|Also works for *=, /=, %=, |=, &=, ^=, <<= and >>=.

..Location Control

org 9000h
|Set the address to assemble to 0x9000.

phase address
|Continue to produce code and data for loading at the current address
|but assemble instructions and define labels as if they originated at
|the given address.  Useful when producing code that will be copied to
|a different location before being executed (e.g., an overlay).

dephase
|End phase mode assembly.

aseg
cseg
dseg
|Switch to the absolute, code and data segments respectively.
|No effect unless ZMAC is producing ".rel" output.

common /name/
|Set the address to the start of the selected common block.  The blank
|common block will be selected if name is empty or all blanks or
|omitted entirely.
|No effect unless ZMAC is producing ".rel" output.

..Input Control

end
|Ends the input.  Any lines after an end are silently ignored.
|If an arg is given, it declares the entry address for the program.
|This has no effect in ".cim" output. In ".hex" output
|it generates an S-record directing 0 bytes of data to be loaded
|at the given address.  It is required for ".500.cas", ".1000.cas"
|and ".1500.cas" output.

if ... [ else ... ] endif
|For conditional assembly. If you do if foo and foo evaluates to
|zero, all the lines up until the next corresponding else or endif
|are completely ignored.  Conversely, if foo evaluates to non-zero, any
|lines from a corresponding else to the endif are ignored.  Ifs can
|be nested.  cond/endc are synonyms for if/endif.

ifdef symbol
|Like if, but tests if symbol has been defined.  Declaring a symbol
|as external counts as it being defined.

ifndef symbol
|Like if, but tests if symbol has not yet been defined.

ifeq expr1,expr2

ifne expr1,expr2

iflt expr1,expr2

ifgt expr1,expr2
|Shorthand for if expr1 == expr2, !=, <, >.  For MRAS and MAC80
|compatibility.

import file
|Like include but will only bring in the file once.  File tracking is done
|using only the file name so, for example, an import file will stop
|both import ./file and import dir/file even if they actually refer to
|different files.

include file
|Include a file. Like C's (well, cpp's) #include and follows the same
|include path search rules, but the filename arg
|lacks the angle brackets or quotes (though single or double quotes may be used).
|read is a synonym.  *include file and *get file work if started in the
|first column.  In --mras mode ".asm" will be added if file has
|no suffix and file/ext will be changed to file.ext   Original MRAS
|source uses TRS-80 file system names where / is the extension
|introducer.

maclib file
|Like include but adds .lib to the file name so includes file.lib.

comment X
|Suspend assembly until the next occurence of character X on a line.
|The rest of the line will be ignored.  A multi-line comment.

assert expr
|Stop assembly if expr is non-zero.

..Cycle Counting

sett expr
|Set the current T-state count to expr. tstate is a synonym.

setocf expr
|Set the current opcode fetch count to expr.

..Code Generation

8080
|Make cycle counting operators return 8080 cycle counts and
|interpret any ambiguous assembly statements as Intel 8080 mnemonics.
|CP will be interpreted as "call on positive" and JP as "jump on positive".

z80
|Make cycle counting operators return Z-80 cycle counts and
|interpret any ambiguous assembly statements as Zilog Z-80 mnemonics.
|CP will be interpreted as "compare accumulator" and JP as "jump unconditionally".

z180
|Allow assembly of Z-180 instructions.
|Make cycle counting operators return Z-180 cycle counts and
|interpret any ambiguous assembly statements as Zilog Z-180 mnemonics.
|CP will be interpreted as "compare accumulator" and JP as "jump unconditionally".

jperror enable
|If enable is non-zero, turn on errors when JR instructions could be used
|instead of JP, off otherwise.  Used to check existing code for situations
|where shorter code could be generated.  Same as -J option.
|No effect if in 8080 mode.

jrpromote enable
|If enable is non-zero, JR and DJNZ instructions will be promoted to
|equivalent JP and DEC##B, JP##NZ instructions if the relative branch
|offset is out of range.  If enable is zero, promotion is disabled.
|Same as the -j option.
|No effect if in 8080 mode.

..Undocumented Instructions\undoc

Most Z-80 chips support a number of undocumented instructions that were part of
the original design but not made an offical part of the Zilog specification.
These instructions may not be supported by all Z-80 chips, especially
licensed variants, but are fairly widely available nonetheless.

sl1 r
|Same as sla r but shifts a 1 into the lower bit of r rather than a 0.

in (c)
|Inputs a byte from port c but does not store the value.  Flags are still
|set as with the normal in r,(c) instruction.

out (c),0
|Outputs a zero to port c.

bit/set/res n,(ix+d),r

rlc/rrc/rl/rr/sla/sl1/sra/srl (iy+d),r
|Same as the corresponding operation on just (ix+d) or (iy+d) but with
|the result being stored both into (ix+d) and register r.  Except for bit
|which has no effect on r. ZMAC supports the syntax to allow those
|instruction patterns to be generated.

The upper and lower bytes of the ix and iy can be used in a number of
instructions much in the same way as d and e correspond to the upper and
lower bytes of de.  ZMAC names these ixh, ixl, iyh and iyl.
Also acceptable are xh, xl, yh, yl and hx, lx, hy, ly.
They are referred to generically as ixylh here.

inc/dec/add/adc/sub/sbc/and/xor/or/cp ixylh
|Arithmetic or logical operation on ix or iy high or low byte.

ld a/b/c/d/e,ixylh
|Load register with ix or iy high or low byte.

ld ixylh,a/b/c/d/e
|Load ix or iy high or low byte with register.

pfix

pfiy
|Output $DD and $FD prefix bytes.  The Z-80 allows multiple prefix bytes
|for IX and IY instructions.  This allows you to specify them abstractly.
|There is little purpose except for delaying an interrupt or confusing
|disassemblers.

..Miscellaneous

pragma str ...
|Like C's #pragma, a generic hook for special purpose operations.  Only two
|are currently defined.

|pragma bds rest-of-line to
|output rest-of-line to the .bds output file.

|pragma mds rest-of-line to
|output rest-of-line to the .mds output file.

|The .bds output format supports setting initial values for Z-80 registers
|and I/O ports so pragma gives you access to that.

|The .mds output format is a MAME debug script thus additional initial
|debugging commands may be output.  Of particular use on the TRS-80 Model II
|is pragma mds ib@$ff=1 which maps page 1 of RAM into $8000 .. $FFFF
|and thus allows programs to load into that area.

name str
|Set the name of the output module to str.  For compatibility reasons
|str may be parenthesized (e.g., "name ('foo')").  Not all output
|formats support an internal name and many have severe length limits.

rsym and wsym
|Read/write a symbol file. These simply load/save the currently defined
|symbols from/to the file specified (in a non-portable format). rsym
|takes place at the point it is encountered in the file (on the first
|pass); wsym is delayed until assembly has finished.

..Listing Pseudo-ops

There are several pseudo-ops for controlling the listing. None of
these ops appear in the listing themselves:

eject
|Start a new listing page.

nolist
|Do nothing. This can be used to have a comment in the source but not
|the listing, I suppose.

elist, flist, glist, mlist
|These have the same effect as the similarly-named command-line
|options, though possibly with the sense reversed depending on the
|default. Use an arg >0 (or no arg) to enable, and an arg <0 to
|disable.

list arg
|Turns output to listing file (.list) off if arg < 0 or on if arg > 0.
|If no arg supplied then listing is enabled.
|Use this to avoid listing certain parts of the source.
|In --mras mode arg must be either on or off and
|*list can be used if started in the first column.

title
|Set title (used in listing and symbol file).

space arg
|Output arg blank lines in the listing, or one line if no arg is given.

---

.Expressions\expr

Expressions feature a full set of C operators with the same precedence
rules and some common assembler extensions and names.
Here is the complete list of operators, highest-precedence first.
Operators separated only by a space are synonyms; for example, ~
is the same as not.

! (logical), ~ not (bitwise), + (unary), - (unary), low, high, t, tilo, tihi, ocf

*, /, % mod

+, -

<< shl, >> shr

< lt, > gt, <= le, >= ge

== = eq, != <> ne

& and (bitwise)

^ xor (bitwise)

| or (bitwise)

&&

||

? :  (ternary choice operator)

Expressions\mrasord change significantly in --mras mode:
|Evaluation is strictly left to right.  Except for and, or,
|xor and =.  This doesn't break compatibility as original MRAS
|source code only allows .and., .or. and .xor. but the precedence
|difference may surprise if code is added.

|! is bitwise OR instead of logical not.

|< is left shift (or right shift when shift amount is negative)

|MRAS operators (.and. .eq. .ge. .gt. .high. .le. .low.
|.lt. .mod. .ne. .not. .or. .shl. .shr. .xor.)
|are recognized even if apparently in identifers.  (e.g., a.or.b is
|seen as a .or. b).

|Logical operators return -1 for true and 0 for false.  Normally
|ZMAC, like C, uses 1 for true.

You can use normal parentheses or square brackets to override
the precedence rules. Square brackets can be used where parentheses would
conflict with Z-80 mnemonic syntax, but this is not necessary in any
practical case.

The ? may need spaces around it to distinguish it from a label that
has ? in it.

The unary operators not familiar to C programmers:

 low expr
  Returns low 8 bits of expr

 high expr
  Returns high 8 bits of expr

 t expr
  Current count of T-states up to memory location expr

 tilo expr
  Low count of T-states used by instruction at memory location expr

 tihi expr
  High count of T-states used by instruction at memory location expr

 ocf expr
  Current count of opcode fetches up to memory location expr
---
.Macros
The following defines a macro named m with zero or more formal parameters
p1, p2, ..., pn, zero or more local symbols ?s1, ?s2, ..., ?sm,
and body b1, b2, ...:

 m macro p1, p2, ..., pn, ?s1, ?s2, ..., ?sm

 ####b1

 ####b2

 ####...

 ####endm

The macro is called by writing:
|m v1, v2, ..., vn

A macro call expands to the text of the macro's body, with each
occurrence of a formal parameter pk replaced by the corresponding
value vk, and with each local symbol ?sk replaced by a new, unique
symbol invented for this call.  Invented symbols begin with ?,
so you should avoid using such symbols elsewhere in your program.

ZMAC currently does not check that you have provided the right number
of parameters when calling a macro.  If you provide too few, unmatched
formals are replaced with the empty string.  If you provide too
many, the additional values begin to replace local symbols as if
they were ordinary parameters.  (This could be considered a feature.)
After the local symbols are all replaced, additional parameters
are silently ignored.

For compatibility with Macro-80, the first line of a macro definition can
list other labels that will be treated locally:

|####local lab1,lab2,...

Each time the macro is expanded the local labels are replaced with unique
names thus avoiding multiple definition problems.

For compatability with MRAS, macro arguments may be preceeded by #
in their definition and use.

Any ` (backquote) in a macro is ignored thus allowing a macro to
construct identifiers.  For example:

 move macro dir

 ######ld`dir`r

 ######endm

Invoking move i will construct a ldir block move instruction.

For compatibility, & can also be used as in MAC to concatenate
macro parameters.  This conflicts with ZMAC's bitwise and operator but
you can use the and synonym in macros to avoid the conflict.

In --mras mode arguments will be expanded even if they are inside other
identifiers.  The move could be written:

 move macro dir

 ######lddirr

 ######endm

Macro definitions can contain macro definitions which will be defined
when the outer macro is first exapnded.  Macros can be redefined as
well.

Macro expansion continues to the endm directive but can be stopped
prematurely by the exitm directive.  Typically the exitm is inside
some conditional part of the macro.

Parameters passed to a macro can be empty and are tested with the nul
operator:

 if nul &par

 ...

 endif

Macro parameters can contain commas if grouped inside < and >.
Or a comma can be escaped with ^ which can also escape spaces and other
special characters.  It is also be put in front of a macro parameter
name inside the expansion to suppress the replacement by its value.

Expansion of parameters in a macro body is purely textual.  This can
lead to surprises in complex situations.  The % character can be used
to force a macro parameter to be replaced with the evaluation of it
as an expression.


..Inline Macros

ZMAC supports the commonly available rept, irp and irpc inline macros

rept repeats its block the given number of times.  This will output 10
nop instructions:

 rept 10

 ######nop

 endm

irpc runs through a string of letters assigning them to a variable and
expanding the macro block each time.  For example, this will load 7 into
registers b, d and h:

 irpc reg,bdh

 ######ld &reg,7

 endm

irp runs through a list of parameters assiging each entry to a variable
and expanding the macro block.  Here we load bc, de and hl with 0:

 irp rpair,<bc,de,hl>

 ######ld &rpair,0

 endm

Lists can be nested.  Here's an example of and irp passing lists on down
to another irp:

 irp listlist,<<one,two,three>,<four,five,six>>

 irp list,<listlist>

 ascii '&list'

 endm

 endm


---
.Compatibility

ZMAC is broadly compatible with many original Z-80 and 8080 assemblers
because it accepts many different names for common operations and has
liberal identifier and numeric formats.  It also accepts most simple
usage of macros.

When assembling old code keep these portability problems in mind.

Expression order of evaluation may be different.  ZMAC uses C semantics
more order of evaluation but assemblers often used simple left to right
ordering.  ZMAC will evaluate 2+2*3 as 8 where other assemblers will
yield 12.  However, in --mras mode expressions are evaluated strictly
left-to-right for compatibility.

ZMAC has no support operating on strings in macros.  Assemblers like Macro-80
could perform conditional tests on strings.

Advanced macros are unlikely to work.  ZMAC hasn't advanced to the state where
all the possible ways of substituting parameters are supported.

Consult the original assembler manual.  ZMAC error messages won't help you
figure out what an unknown assembler command is supposed to do.

Compare against original output.  The very safest thing to do when porting
assembly code is to compare the binary output of ZMAC against that produced
by the original assembler.  This way you can ensure everything has been
interpreted correctly.  Only once that has been achieved should you modify
the code.
---
.Errors and Warnings

Any errors or warnings encountered during assembly are reported to standard
error and in the listing file.  The errors output immediately give the source
file and line number containing the error.  In listings the error letter
and message appear just after the line containing the error.

 B
  Balance error
 ##
  A string is missing an closing quote or an if is missing an endif
 E
  Expression error
 ##
  An expression did not parse or attempts a divide or modulus by 0.
 F
  Syntax error
 ##
  General problem with the syntax on a line.  Sometimes extra explanation
  will be printed on standard output.
 I
  Digit error
 ##
  A numeric constant has too many digits to be represented as a 32 bit number.
 M
  Mult. def. error
 ##
  A symbol has been defined more than once and those values differ.
 P
  Phase error
 ##
  On the second or subsequent assembly passes the assembly has changed
  significantly.  Most commonly it means an if has changed conditions
  but can also happen when labels or equated values do not converge to
  a fixed value.
 U
  Undeclared error
 ##
  An undeclared symbol was used in an expression or public statement.
 V
  Value error
 ##
  An invalid value was given to a statement.  Often this means using less
  than -128 or greater then 255 in a defb or less than -32768 or greater
  than 65535 in a defw.  Or similar invalid values used Z-80/8080 opcodes
  requiring an 8 or 16 bit value (and other restrictions like 0 to 7 for BIT).
  Also if a relative jump is out of range or if a negative value is given
  in defs or dc.
 O
  Phase/Dephase error
 ##
  phase was used within another phase or dephase without phase.
  Or if org is used within phase.
 A
  Assertion failure error
 ##
  An assert statement evaluated to zero.
 J
  Use JR error
 ##
  An absolute jump instruction was used where relative jump was in range
  of the destination address.  Only generated if -j or jrpromote is
  in effect.
 R
  Not relocatable error
 ##
  An expression was used that must be generated at link time but cannot
  be handled by the ".rel" format.  For instance, an org to a symbol in
  the data segment when in the code segment.  Or a relative jump to a
  different segment.  The ".rel" format can evaluate expressions at link
  time using the high, low, not, -, +, *, / and % operators.
  ZMAC is clever enough to use high or low in place of & $ff00 and
  & 255.  But it won't replace a shl with a multiply.
 G
  Register usage error
 ##
  A invalid register was given to an instruction.  For example, LD B,(DE)
  or ADD HL,IX.
 Z
  Invalid instruction.
 ##
  The instruction is not valid for the current architecture.  For example,
  a Z-80@zmn instruction in 8080 mode (.8080 or -8 mode is in effect).
  Or a Z-180@zzmn instruction in 8080 or Z-80 mode.
  Or an undocumented Z-80 instruction in Z-180 mode.
  However, use use of Z-80 mnemonics that
  output valid 8080 instructions is always OK.
 H
  $hex constant interpreted as symbol warning
 ##
  A symbol such as $FCB has been defined even though it could appear to
  be a hexadecimal constant.  ZMAC will treat $FCB as symbol for the entire
  assembly which could be rather surprising if that were not the intent.
 N
  Not implemented warning
 ##
  For statements that have been added as parse rules but have no effect.
  The only current example is subttl which sets the sub title of a listing
  in certain assemblers.
 W
  Generic warning
 ##
  Higher-level warning; see text of warning for explanation.

---
.Output Formats\format

Except for ".rel", ZMAC writes every known output when assembling by default.
This is no burden on modern computers and saves having to meticulously select
the desired output format.

".rel" is a special case since that format is intended for linking and
can have undefined external symbols which would be errors in the other formats.
Conversely, a simple "org $8000" will be an error for ".rel" output as it
defaults to the code segment where absolute origin statements are forbidden.

If ".rel" is selected for output either by --relopt or with
--oo rel or -o file.rel then all other output formats are suppressed
(except the ".lst" source file listing).

 .ams
  AMSDOS executable format for Amstrad computers.
 .bds
  For source-level debugging and automatic memory protecttion in
  trs80gp@http://www.48k.ca/trs80gp.html
 .1500.cas
  TRS-80 high-speed (1500 baud) cassette SYSTEM file.  The internal name of the
  file is the source file name shortened to 6 characters with suffixes
  removed.  Requires an entry address.
 .250.cas
  TRS-80 250 baud cassette Level I CLOAD file.  If your program has an
  entry address and $41FE does not contain that entry address then the file
  will be loaded at $41FE with relocation code added to move it to the desired
  location.
 .500.cas
  TRS-80 low-speed (500 baud) cassette SYSTEM file.  The internal name of the
  file is the source file name shortened to 6 characters with suffixes removed.
  Requires an entry address.
 .1000.cas
  Identical to 500 baud but intended for double-speed LNW-80 which can
  can load cassette files at double speed for an effective 1000 baud rate.
  Requires an entry address.
 .cim
  Core In-Memory image.  A raw binary format with the first byte corresponding
  to the lowest generated code or data and proceeding contiguously until the
  highest address generated.  Any gaps are filled with zeros.  Typically used
  for CP/M where all executables start at address 256 or for ROM images.
 .cmd
  TRS-80 DOS executable file format as used by all major DOSes on the TRS-80
  (TRS-DOS, LDOS, MULTIDOS, NEWDOS, etc.)
 .hex
  Intel hex record format.
 .rel
  Relocatable object module format as produced by MACRO-80 and other assemblers.
 .tap
  ZX Spectrum cassette tape format.
 .1500.wav
  Same as .1500.cas but in ready-to-play audio format.
 .250.wav
  Same as .250.cas but in ready-to-play audio format.
 .500.wav
  Same as .500.cas but in ready-to-play audio format.
 .1000.wav
  Same as .1000.cas but in ready-to-play audio format.
 .mds
  MAME debug script (e.g., mame trs80 -d -debugscript zout/prog.mds)

---
.Miscellaneous
In the symbol table listing, the = separator is given for those symbols
defined by equ or defl.  The / separator is shown for common blocks.
Aliases are distinguished by their double-quoted strings.

The .rel file format can store symbol names of up to 7 characters in length.
However, MACRO-80 truncates symbols to 6 characters so that it has one
character in reserve for extending linking operations such as subtracting
two externals from each other.  To be compatible (and sensible), --rel
truncates externals to 6 characters.  For MRAS compatibility, --mras
truncates symbols to 7 characters.  This is not a problem for MRAS as it
doesn't support extended linking.  But necessary if you want ZMAC to produce
.rel files that will link with MRAS generated .rel files.  The --rel7
option sets symbol truncation to 7 characters so you can assemble files
that will link with MRAS output.  However, it will break extended linking
on labels longer than 6 characters.

The ignoring\prime of single quotes can be handy for tracking alternate
register usage.  Consider the following code fragment:

 ld    a,(hl)

 rra

 exx

 ld    a,(hl')

 ex    af,af'

 ld    a',(hl')

 rra'

 ex    af,af'

 djnz' loop

 ld    d',e'

 exx

Although ZMAC does nothing but ignore the single quotes they are useful for
indicating which register is currently active.  A more advanced mode
where ZMAC pays attention to the trailing quotes and emits exchange
instructions as needed has been considered.

---
.Official Zilog\zsyn Syntax

The official Zilog syntax for Z-80 has some rather arbitrary restrictions
that ZMAC ignores.  For instance, add a,b is the only correct form but
sub a,b is invalid as sub b must be used.
Here is a list of
the official and alternate forms of the various affected instructions.
rmn refers to a, b, c, d, e, h, l, (hl), (ix+d), (iy+d)
or 8 bit immediate value.

    Official        Accepted Variant

  add   a,rmn         add   rmn

  adc   a,rmn         adc   rmn

  sub   rmn           sub   a,rmn

  sbc   a,rmn         sbc   rmn

  cp    rmn           cp    a,rmn

  and   rmn           and   a,rmn

  xor   rmn           xor   a,rmn

  or    rmn           or    a,rmn

  jp    (hl)          jp    hl

  jp    (ix)          jp    ix

  jp    (iy)          jp    iy

  ex    de,hl         ex    hl,de

  ex    hl,(sp)       ex    (sp),hl

  ex    ix,(sp)       ex    (sp),ix

  ex    iy,(sp)       ex    (sp),iy

  in    a,(n)         in    a,n

  out   (n),a         out   n,a

  in    r,(c)         in    r,(bc)

  out   (c),r         out   (bc),r

  rst   8             rst   1

  rst   16            rst   2

  rst   24            rst   3

  rst   32            rst   4

  rst   40            rst   5

  rst   48            rst   6

  rst   56            rst   7

---
.Mnemonic Values\mneval

Values for 8080 mnemonics.  Note that cpi and jp are interpreted as
"compare immediate" and "jump if positive" in 8080 mode.

  aci $CE    dad $09   ldax $0A    rnz $C0

  adc $88    dcr $05   lhld $2A     rp $F0

  add $80    dcx $0B    lxi $01    rpe $E8

  adi $C6    dec $01    mov $40    rpo $E0

  ana $A0     di $F3    mvi $06    rrc $0F

  ani $E6     ei $FB    nop $00    rst $C7

 call $CD    hlt $76    ora $B0     rz $C8

   cc $DC     in $DB    ori $F6    sbb $98

   cm $FC    inr $04    out $D3    sbi $DE

  cma $2F    inx $03   pchl $E9   shld $22

  cmc $3F     jc $DA    pop $C1   sphl $F9

  cmp $B8     jm $FA   push $C5    sta $32

  cnc $D4    jmp $C3    ral $17   stax $02

  cnz $C4    jnc $D2    rar $1F    stc $37

   cp $B8    jnz $C2     rc $D8    sub $90

  cpe $EC     jp $F2    ret $C9    sui $D6

  cpi $FE    jpe $EA    rlc $07   xchg $EB

  cpo $E4    jpo $E2   rlcr $07    xra $A8

   cz $CC     jz $CA     rm $F8    xri $EE

  daa $27    lda $3A    rnc $D0   xthl $E3

Values for Z-80\zmn mnemonics.
Ambiguous mnemonics such as ld and inc evaluate to the 8 bit register
operation base value.  ex is arbitrarily mapped to ex de,hl.
Bit and shift operations on (IX+d) and (IY+d)
evaluate to 32 bit values and the offset goes into the third byte.
and, or and xor can be used in data statements but parsing ambiguity
prevents their use in operations.

 adc      $88            otir     $B3ED

 adcx     $8EDD          out      $D3

 adcy     $8EFD          outd     $ABED

 add      $80            outdr    $BBED

 addx     $86DD          outi     $A3ED

 addy     $86FD          outir    $B3ED

 and      $A0            outp     $41ED

 andx     $A6DD          pcix     $E9DD

 andy     $A6FD          pciy     $E9FD

 bit      $40CB          pfix     $DD

 bitx     $4600CBDD      pfiy     $FD

 bity     $4600CBFD      pop      $C1

 call     $CD            popix    $E1DD

 ccd      $A9ED          popiy    $E1FD

 ccdr     $B9ED          push     $C5

 ccf      $3F            pushix   $E5DD

 cci      $A1ED          pushiy   $E5FD

 ccir     $B1ED          ralr     $10CB

 cmpx     $BEDD          ralx     $1600CBDD

 cmpy     $BEFD          raly     $1600CBFD

 cp       $B8            rarr     $18CB

 cpd      $A9ED          rarx     $1E00CBDD

 cpdr     $B9ED          rary     $1E00CBFD

 cpi      $A1ED          res      $80CB

 cpir     $B1ED          resx     $8600CBDD

 cpl      $2F            resy     $8600CBFD

 daa      $27            ret      $C9

 dadc     $4AED          reti     $4DED

 dadx     $9DD           retn     $45ED

 dady     $9FD           rl       $10CB

 dcrx     $35DD          rla      $17

 dcry     $35FD          rlc      $CB

 dcxix    $2BDD          rlca     $7

 dcxiy    $2BFD          rlcr     $CB

 dec      $5             rlcx     $600CBDD

 di       $F3            rlcy     $600CBFD

 djnz     $10            rld      $6FED

 dsbc     $42ED          rr       $18CB

 ei       $FB            rra      $1F

 ex       $EB            rrc      $8CB

 exaf     $8             rrca     $F

 exx      $D9            rrcr     $8CB

 halt     $76            rrcx     $E00CBDD

 im       $46ED          rrcy     $E00CBFD

 im0      $46ED          rrd      $67ED

 im1      $56ED          rst      $C7

 im2      $5EED          sbc      $98

 in       $DB            sbcd     $43ED

 inc      $4             sbcx     $9EDD

 ind      $AAED          sbcy     $9EFD

 indr     $BAED          scf      $37

 ini      $A2ED          sded     $53ED

 inir     $B2ED          set      $C0CB

 inp      $40ED          setb     $C0CB

 inrx     $34DD          setx     $C600CBDD

 inry     $34FD          sety     $C600CBFD

 inxix    $23DD          sixd     $22DD

 inxiy    $23FD          siyd     $22FD

 jp       $F2            sl1      $30CB

 jr       $18            sla      $20CB

 jrc      $38            slar     $20CB

 jrnc     $30            slax     $2600CBDD

 jrnz     $20            slay     $2600CBFD

 jrz      $28            sll      $30CB

 lbcd     $4BED          spix     $F9DD

 ld       $40            spiy     $F9FD

 ldai     $57ED          sra      $28CB

 ldar     $5FED          srar     $28CB

 ldd      $A8ED          srax     $2E00CBDD

 lddr     $B8ED          sray     $2E00CBFD

 lded     $5BED          srl      $38CB

 ldi      $A0ED          srlr     $38CB

 ldir     $B0ED          srlx     $3E00CBDD

 ldx      $46DD          srly     $3E00CBFD

 ldy      $46FD          sspd     $73ED

 lixd     $2ADD          stai     $47ED

 liyd     $2AFD          star     $4FED

 lspd     $7BED          stx      $70DD

 lxix     $21DD          sty      $70FD

 lxiy     $21FD          sub      $90

 mvix     $36DD          subx     $96DD

 mviy     $36FD          suby     $96FD

 neg      $44ED          xor      $A8

 nop      $0             xorx     $AEDD

 or       $B0            xory     $AEFD

 orx      $B6DD          xtix     $E3DD

 ory      $B6FD          xtiy     $E3FD

 otdr     $BBED

Values for Z-180\zzmn mnemonics.

 in0      $00ED

 mlt      $4CED

 otdm     $8BED

 otdmr    $9BED

 otim     $83ED

 otimr    $93ED

 out0     $01ED

 slp      $76ED

 tst      $04ED

 tstio    $74ED

---
.Exit Status

 0
  No errors.
 1
  One or more errors were found during assembly, or ZMAC exited with a
  fatal error.

--
.Credits
Bruce Norskog originally wrote ZMAC in 1978.

Updates and bugfixes over the years by John Providenza, Colin Kelley,
and more recently by Russell Marks, Mark RISON, Chris Smith,
Matthew Phillips and Tim Mann.

Extensive modifications for cycle counting, multiple output formats,
".rel" output, 8080 mode and older assembler compatibilty were written
by George Phillips.

This document was based on Russell Marks ZMAC man page which had
tweaks by Mark RISON and Tim Mann.  George Phillips converted it to HTML
and documented the new features and some older ones (e.g., phase/dephase).
