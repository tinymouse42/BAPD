      ________      _____ ______       ________      ________
      |\_____  \    |\   _ \  _   \    |\   __  \    |\   ____\
       \|___/  /|   \ \  \\\__\ \  \   \ \  \|\  \   \ \  \___|
           /  / /    \ \  \\|__| \  \   \ \   __  \   \ \  \
          /  /_/__    \ \  \    \ \  \   \ \  \ \  \   \ \  \____
         |\________\   \ \__\    \ \__\   \ \__\ \__\   \ \_______\
          \|_______|    \|__|     \|__|    \|__|\|__|    \|_______|

___ _  _        _  __ _  _     __ _  _  __ __    _  __ __ __    _     __ _
 _/(_)/ \   |V||_|/  |_)/ \   /  |_)/ \(_ (_ ---|_|(_ (_ |_ |V||_)|  |_ |_)
/__(_)\_/   | || |\__| \\_/   \__| \\_/__)__)   | |__)__)|__| ||_)|__|__| \


******************************************************************************
Version: 18oct2022
This updated version was of ZMAC was produced by George Phillips
http://48k.ca/zmac.html
For full credits, please see the end of this document.

NOTE: This is a modified and abridged version for the Bally Astrocade Program Development (BAPD) program. With any major document change errors could creep in. If something does not behave as the documentation states, please see the original full documentation at the link above.
-Dave Turner 05/09/2024
******************************************************************************

OVERVIEW

ZMAC is a versatile Z-80 macro cross-assembler. It takes your source code and generates executable program files in various formats. ZMAC also creates a '.lst' file, providing a well-formatted listing of your code alongside machine code and cycle counts for analysis. Undocumented Z80 instructions are supported. See http://www.z80.info/zip/z80-documented.pdf for more information.

USAGE

zmac
[ --help ]
[ --version ]
[ --od dir ]
[ --oo sfx1,sfx2 ]
[ --xo sfx1,sfx2 ]
[ --nmnv ]
[ --fcal ]
[ --doc ]
[ -bcfimnopstz ]

OPTIONS

--help

Displays a list of available options with brief descriptions.

--version
Prints the current ZMAC version.

--od dir
Sets the default output directory to the user-specified directory (dir). All generated files will be placed in this directory unless otherwise specified.

--oo sfx1,sfx2
Enables output in the specified formats.  Example: --oo hex,lst,bin
Refer to ZMAC documentation for a full list of supported suffixes.

--xo sfx1,sfx2
Disables output in the specified formats. Example: zmac --xo lst,hex project.asm This example suppresses the generation .lst and and .hex files.
All other standard output files would still be produced.

--nmnv
Disables the use of Z-80/8080 instruction mnemonics as values within expressions.  Example: DEFB ret  ; Error: 'ret' would be undefined.

--doc
Prints the full ZMAC documentation in HTML format to standard output.

--fcal
Any identifier in the first column must have a colon to be considered a label.

-b
Suppresses machine code output. Useful for syntax checks or when only the listing file is needed.

-c
Suppresses the display of cycle count information in the assembly listing.

By default, ZMAC includes cycle counts for each instruction, aiding in performance analysis.

ZMAC Default:

Address  Machine Code  Assembly      Cycles
-------  ------------  ---------     ------
0000     3E 0A         ld a,10       7

With -c Option: The cycle count column is removed:

Address  Machine Code  Assembly
-------  ------------  ---------
0000     3E 0A         ld a,10

-f
Includes instructions that were excluded from assembly due to IF expressions evaluating to false.

-i
Suppresses the display of files included using INCLUDE, READ, or INPORT.

-I dir
Adds user-specified directory (dir) to the search path for files for INCLUDE, READ, or INPORT.

-m
Displays macro expansions in the assembly listing for debugging and analysis.

-o filename.cmd
Instructs ZMAC to generate only the file with the specified name and suffix (e.g., .hex, .bin .lst) overriding ZMAC's default behavior of creating multiple output formats. Example: zmac -o program.hex will only generate the .hex file and suppress all others. It can be used multiple times in a single command. Example: zmac -o program.hex -o program.bin program.asm would only generate the .hex and .bin files.

-s
Omits the symbol table from the assembly listing.

-z

Enables Z-80 mnemonics and instruction timings.

Z-80 Mnemonics:  Tells ZMAC to recognize and assemble the full set of Z-80 instructions, including those that are not part of the original 8080 instruction set.
Z-80 Instruction Timings: Instructs ZMAC to use the correct cycle counts for all Z-80 instructions when calculating timing information for your code.



---
.Input Format

ZMAC uses the standard Zilog mnemonics and assembler directives. Variations that are valid are listed below.

ZMAC is case-insensitive, meaning that uppercase, lowercase, or mixed case is considered the same. Example: LABEL1, Label1 and LaBel1 are treated as the same word.

A leading dot (".") can be optionally added to any directive. For example, ".org" and "org" are equivalent.

Comments start with ";" and carry on to the end of the line.

Number constants can use a trailing "h" or a leading "$" or "0x" for hex,
a trailing "b" for binary, a trailing "o" or "q" for octal, or a trailing
"d" for decimal. Since decimal is the default, you can omit the trailing "d" (e.g., 123 is the same as 123d).

For flexibility, ZMAC allows you to use assembly mnemonics directly as data values. For example, "mvi a,xra" will load the A register with $A8 and "dw ldir" will output the same data as an ldir instruction ($B0ED). This feature can be disable with the --nmnv command-line option.

Define labels using either 'label:' or simply 'label'. Indentation doesn't matter. Labels can be up to 40 characters long and may contain letters, digits, '_', '$', '.', '?', and '@'.  Identifiers like '$FCB' are treated as hexadecimal constants unless you explicitly define them as labels by adding a trailing colon (e.g., '$FCB:'). Labels are case insenitive.

Alternate Register Notation: You can add a single quote (') to the end of register names to indicate the use of alternate registers with the exx and ex instructions but this is optional. Example: ex af, af' and ex af, af are considered equivilent. Using the single quote feature improves code readability, especially when performing many register swaps.



[DATA]


DEFB

Purpose: Defines one or more bytes in memory.
Usage:
Numbers: DEFB 10, 25, 128 (Individual bytes separated by commas)
Strings: DEFB 'Hello world!' or DEFB "Hello world!" (Enclosed in quotes)
Mixed: DEFB 'X', 50, "more data" (Combine bytes and strings freely)
Synonyms:  ASCII, BYTE, DB, DEFM, DM, TEXT


DEFW

Purpose: Defines one or more 16-bit words in memory.
Example: defw 123, 0x456, 50000 (Individual words separated by commas)
Synonyms: WORD, DW


DEFW

DEFW $123,0x456
A word (16 bits).  word and dw are synonyms.



DEFS

Purpose: Skips ahead a specified number of bytes in the output, effectively reserving memory space.
Usage:
Numbers: DEFS 500
Synonyms: DS, BLOCK, RMEM


DC count, byte

Purpose: Repeats a byte value a specified number of times, filling memory.
Usage:
Numbers: DC count, value. Example: dc 10, 50  would fill 10 consecutive memory locations with the value 50.

INCBIN file

Purpose: Tells the assembler to directly include the raw contents of a file into the final assembled binary program.
Benefits:
Simplifies including large datasets like images or sound effects.
Avoids manually entering large amounts of data in your assembly code, which can be error-prone.
Important Note: incbin doesn't insert the file itself into your assembly text file.  Instead, it incorporates the file's raw data (bytes) into the final binary program you create after assembly.



[SYMBOLS]

Symbols: General names representing values or memory locations within your assembly code.
Labels: A specific type of symbol primarily used to mark locations in your code that you can jump or branch to.

EQU

Usage: symbol EQU value
Example: loop_count EQU 5   ; Defines 'loop_count' to represent the number 5
Notes:
Defines a symbol with a fixed value that cannot be changed later.
The symbol can be used before its definition in your code.


=============================


varname defl 200
|Define a symbol to have a changeable value.  The symbol cannot be used
|before it is defined, and it can be redefined to a different value later
|with another defl. aset, set and = are synonyms (despite set
|also being a Z-80 mnemonic).

varname OP = expression
|Shorthand for varname defl varname OP expression.  Allows for C-like
|handling of variable such as var += 5.  OP can be +, -, *, /,
|%, &, |, ^, <<, >>, && or ||.

varname++
|Shorthand for varname defl varname + 1

varname--
|Shorthand for varname defl varname - 1

min

max
|Same as defl except that the symbol is defined as the
|smaller or bigger of two comma-separated expressions.

name equ register
|Define a symbol to be an alias of a register.  count equ bc lets count
|stand for register bc so push count and dec count will both operate on
|register bc.

*mod
|Increment the internal module name string.  The first time this results
|in "a".  Then "b", "c", ... "z".  Then "aa", "ab", "ac", etc. all the way
|up to "zzzz".  The module name string is used in --mras mode where "?" in
|label names is replaced with the current module name.

extern lab1,lab2,...
|The listed labels are defined in an external module for later linking.
|No effect unless ZMAC is producing ".rel" output.
|ext and extrn are synonyms.

public lab1,lab2,...
|The given labels will be visible to external modules when linking.
|No effect unless ZMAC is producing ".rel" output.
|global and entry are synonyms.

label ++
|Equivalent to label defl label + 1.

label --
|Equivalent to label defl label - 1.

label += 10

label -= 10

|Equivalent to label defl label + 10 and label defl label - 10 respectively.
|Also works for *=, /=, %=, |=, &=, ^=, <<= and >>=.

..Location Control

org 9000h
|Set the address to assemble to 0x9000.

phase address
|Continue to produce code and data for loading at the current address
|but assemble instructions and define labels as if they originated at
|the given address.  Useful when producing code that will be copied to
|a different location before being executed (e.g., an overlay).

dephase
|End phase mode assembly.

aseg
cseg
dseg
|Switch to the absolute, code and data segments respectively.
|No effect unless ZMAC is producing ".rel" output.

common /name/
|Set the address to the start of the selected common block.  The blank
|common block will be selected if name is empty or all blanks or
|omitted entirely.
|No effect unless ZMAC is producing ".rel" output.

..Input Control

end
|Ends the input.  Any lines after an end are silently ignored.
|If an arg is given, it declares the entry address for the program.
|This has no effect in ".cim" output. In ".hex" output
|it generates an S-record directing 0 bytes of data to be loaded
|at the given address.  It is required for ".500.cas", ".1000.cas"
|and ".1500.cas" output.

if ... [ else ... ] endif
|For conditional assembly. If you do if foo and foo evaluates to
|zero, all the lines up until the next corresponding else or endif
|are completely ignored.  Conversely, if foo evaluates to non-zero, any
|lines from a corresponding else to the endif are ignored.  Ifs can
|be nested.  cond/endc are synonyms for if/endif.

ifdef symbol
|Like if, but tests if symbol has been defined.  Declaring a symbol
|as external counts as it being defined.

ifndef symbol
|Like if, but tests if symbol has not yet been defined.

ifeq expr1,expr2

ifne expr1,expr2

iflt expr1,expr2

ifgt expr1,expr2
|Shorthand for if expr1 == expr2, !=, <, >.  For MRAS and MAC80
|compatibility.

import file
|Like include but will only bring in the file once.  File tracking is done
|using only the file name so, for example, an import file will stop
|both import ./file and import dir/file even if they actually refer to
|different files.

include file
|Include a file. Like C's (well, cpp's) #include and follows the same
|include path search rules, but the filename arg
|lacks the angle brackets or quotes (though single or double quotes may be used).
|read is a synonym.  *include file and *get file work if started in the
|first column.  In --mras mode ".asm" will be added if file has
|no suffix and file/ext will be changed to file.ext   Original MRAS
|source uses TRS-80 file system names where / is the extension
|introducer.

maclib file
|Like include but adds .lib to the file name so includes file.lib.

comment X
|Suspend assembly until the next occurence of character X on a line.
|The rest of the line will be ignored.  A multi-line comment.

assert expr
|Stop assembly if expr is non-zero.

..Cycle Counting

sett expr
|Set the current T-state count to expr. tstate is a synonym.

setocf expr
|Set the current opcode fetch count to expr.

..Code Generation

z80
|Make cycle counting operators return Z-80 cycle counts and
|interpret any ambiguous assembly statements as Zilog Z-80 mnemonics.
|CP will be interpreted as "compare accumulator" and JP as "jump unconditionally".


..Miscellaneous


rsym and wsym
|Read/write a symbol file. These simply load/save the currently defined
|symbols from/to the file specified (in a non-portable format). rsym
|takes place at the point it is encountered in the file (on the first
|pass); wsym is delayed until assembly has finished.

..Listing Pseudo-ops

There are several pseudo-ops for controlling the listing. None of
these ops appear in the listing themselves:

eject
|Start a new listing page.

nolist
|Do nothing. This can be used to have a comment in the source but not
|the listing, I suppose.

elist, flist, glist, mlist
|These have the same effect as the similarly-named command-line
|options, though possibly with the sense reversed depending on the
|default. Use an arg >0 (or no arg) to enable, and an arg <0 to
|disable.

list arg
|Turns output to listing file (.list) off if arg < 0 or on if arg > 0.
|If no arg supplied then listing is enabled.
|Use this to avoid listing certain parts of the source.
|In --mras mode arg must be either on or off and
|*list can be used if started in the first column.

title
|Set title (used in listing and symbol file).

space arg
|Output arg blank lines in the listing, or one line if no arg is given.

---

.Expressions\expr

Expressions feature a full set of C operators with the same precedence
rules and some common assembler extensions and names.
Here is the complete list of operators, highest-precedence first.
Operators separated only by a space are synonyms; for example, ~
is the same as not.

! (logical), ~ not (bitwise), + (unary), - (unary), low, high, t, tilo, tihi, ocf

*, /, % mod

+, -

<< shl, >> shr

< lt, > gt, <= le, >= ge

== = eq, != <> ne

& and (bitwise)

^ xor (bitwise)

| or (bitwise)

&&

||

? :  (ternary choice operator)

Expressions\mrasord change significantly in --mras mode:
|Evaluation is strictly left to right.  Except for and, or,
|xor and =.  This doesn't break compatibility as original MRAS
|source code only allows .and., .or. and .xor. but the precedence
|difference may surprise if code is added.

|! is bitwise OR instead of logical not.

|< is left shift (or right shift when shift amount is negative)

|MRAS operators (.and. .eq. .ge. .gt. .high. .le. .low.
|.lt. .mod. .ne. .not. .or. .shl. .shr. .xor.)
|are recognized even if apparently in identifers.  (e.g., a.or.b is
|seen as a .or. b).

|Logical operators return -1 for true and 0 for false.  Normally
|ZMAC, like C, uses 1 for true.

You can use normal parentheses or square brackets to override
the precedence rules. Square brackets can be used where parentheses would
conflict with Z-80 mnemonic syntax, but this is not necessary in any
practical case.

The ? may need spaces around it to distinguish it from a label that
has ? in it.

The unary operators not familiar to C programmers:

 low expr
  Returns low 8 bits of expr

 high expr
  Returns high 8 bits of expr

 t expr
  Current count of T-states up to memory location expr

 tilo expr
  Low count of T-states used by instruction at memory location expr

 tihi expr
  High count of T-states used by instruction at memory location expr

 ocf expr
  Current count of opcode fetches up to memory location expr
---


.Macros
The following defines a macro named m with zero or more formal parameters
p1, p2, ..., pn, zero or more local symbols ?s1, ?s2, ..., ?sm,
and body b1, b2, ...:

 m macro p1, p2, ..., pn, ?s1, ?s2, ..., ?sm

 ####b1

 ####b2

 ####...

 ####endm

The macro is called by writing:
|m v1, v2, ..., vn

A macro call expands to the text of the macro's body, with each
occurrence of a formal parameter pk replaced by the corresponding
value vk, and with each local symbol ?sk replaced by a new, unique
symbol invented for this call.  Invented symbols begin with ?,
so you should avoid using such symbols elsewhere in your program.

ZMAC currently does not check that you have provided the right number
of parameters when calling a macro.  If you provide too few, unmatched
formals are replaced with the empty string.  If you provide too
many, the additional values begin to replace local symbols as if
they were ordinary parameters.  (This could be considered a feature.)
After the local symbols are all replaced, additional parameters
are silently ignored.

For compatibility with Macro-80, the first line of a macro definition can
list other labels that will be treated locally:

|####local lab1,lab2,...

Each time the macro is expanded the local labels are replaced with unique
names thus avoiding multiple definition problems.

For compatability with MRAS, macro arguments may be preceeded by #
in their definition and use.

Any ` (backquote) in a macro is ignored thus allowing a macro to
construct identifiers.  For example:

 move macro dir

 ######ld`dir`r

 ######endm

Invoking move i will construct a ldir block move instruction.

For compatibility, & can also be used as in MAC to concatenate
macro parameters.  This conflicts with ZMAC's bitwise and operator but
you can use the and synonym in macros to avoid the conflict.

In --mras mode arguments will be expanded even if they are inside other
identifiers.  The move could be written:

 move macro dir

 ######lddirr

 ######endm

Macro definitions can contain macro definitions which will be defined
when the outer macro is first exapnded.  Macros can be redefined as
well.

Macro expansion continues to the endm directive but can be stopped
prematurely by the exitm directive.  Typically the exitm is inside
some conditional part of the macro.

Parameters passed to a macro can be empty and are tested with the nul
operator:

 if nul &par

 ...

 endif

Macro parameters can contain commas if grouped inside < and >.
Or a comma can be escaped with ^ which can also escape spaces and other
special characters.  It is also be put in front of a macro parameter
name inside the expansion to suppress the replacement by its value.

Expansion of parameters in a macro body is purely textual.  This can
lead to surprises in complex situations.  The % character can be used
to force a macro parameter to be replaced with the evaluation of it
as an expression.


..Inline Macros

ZMAC supports the commonly available rept, irp and irpc inline macros

rept repeats its block the given number of times.  This will output 10
nop instructions:

 rept 10

 ######nop

 endm

irpc runs through a string of letters assigning them to a variable and
expanding the macro block each time.  For example, this will load 7 into
registers b, d and h:

 irpc reg,bdh

 ######ld &reg,7

 endm

irp runs through a list of parameters assiging each entry to a variable
and expanding the macro block.  Here we load bc, de and hl with 0:

 irp rpair,<bc,de,hl>

 ######ld &rpair,0

 endm

Lists can be nested.  Here's an example of and irp passing lists on down
to another irp:

 irp listlist,<<one,two,three>,<four,five,six>>

 irp list,<listlist>

 ascii '&list'

 endm

 endm


---
.Compatibility

ZMAC is broadly compatible with many original Z-80 and 8080 assemblers
because it accepts many different names for common operations and has
liberal identifier and numeric formats.  It also accepts most simple
usage of macros.

When assembling old code keep these portability problems in mind.

Expression order of evaluation may be different.  ZMAC uses C semantics
more order of evaluation but assemblers often used simple left to right
ordering.  ZMAC will evaluate 2+2*3 as 8 where other assemblers will
yield 12.  However, in --mras mode expressions are evaluated strictly
left-to-right for compatibility.

ZMAC has no support operating on strings in macros.  Assemblers like Macro-80
could perform conditional tests on strings.

Advanced macros are unlikely to work.  ZMAC hasn't advanced to the state where
all the possible ways of substituting parameters are supported.

Consult the original assembler manual.  ZMAC error messages won't help you
figure out what an unknown assembler command is supposed to do.

Compare against original output.  The very safest thing to do when porting
assembly code is to compare the binary output of ZMAC against that produced
by the original assembler.  This way you can ensure everything has been
interpreted correctly.  Only once that has been achieved should you modify
the code.
---

.Miscellaneous

In the symbol table listing, the = separator is given for those symbols
defined by equ or defl.  The / separator is shown for common blocks.
Aliases are distinguished by their double-quoted strings.


.Exit Status

 0
  No errors.
 1
  One or more errors were found during assembly, or ZMAC exited with a
  fatal error.

--
.Credits
Bruce Norskog originally wrote ZMAC in 1978.

Updates and bugfixes over the years by John Providenza, Colin Kelley,
and more recently by Russell Marks, Mark RISON, Chris Smith,
Matthew Phillips and Tim Mann.

Extensive modifications for cycle counting, multiple output formats,
".rel" output, 8080 mode and older assembler compatibilty were written
by George Phillips.

This document was based on Russell Marks ZMAC man page which had
tweaks by Mark RISON and Tim Mann.  George Phillips converted it to HTML
and documented the new features and some older ones (e.g., phase/dephase).
